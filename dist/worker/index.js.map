{"version":3,"sources":["../../src/worker/index.ts"],"sourcesContent":["import * as Comlink from \"comlink\";\nimport type {\n  PGliteInterface,\n  PGliteOptions,\n  FilesystemType,\n  DebugLevel,\n  Results,\n  QueryOptions,\n} from \"../interface.js\";\nimport type { BackendMessage } from \"pg-protocol/dist/messages.js\";\nimport { parseDataDir } from \"../fs/index.js\";\nimport type { Worker as WorkerInterface } from \"./process.js\";\n\nexport class PGliteWorker implements PGliteInterface {\n  readonly dataDir?: string;\n  readonly fsType: FilesystemType;\n  readonly waitReady: Promise<void>;\n  readonly debug: DebugLevel = 0;\n\n  #ready = false;\n  #closed = false;\n\n  #worker: WorkerInterface;\n  #options: PGliteOptions;\n\n  #notifyListeners = new Map<string, Set<(payload: string) => void>>();\n  #globalNotifyListeners = new Set<\n    (channel: string, payload: string) => void\n  >();\n\n  constructor(dataDir: string, options?: PGliteOptions) {\n    const { dataDir: dir, fsType } = parseDataDir(dataDir);\n    this.dataDir = dir;\n    this.fsType = fsType;\n    this.#options = options ?? {};\n    this.debug = options?.debug ?? 0;\n\n    this.#worker = Comlink.wrap(\n      // the below syntax is required by webpack in order to\n      // identify the worker properly during static analysis\n      // see: https://webpack.js.org/guides/web-workers/\n      new Worker(new URL(\"./process.js\", import.meta.url), { type: \"module\" }),\n    );\n\n    // pass unparsed dataDir value\n    this.waitReady = this.#init(dataDir);\n  }\n\n  async #init(dataDir: string) {\n    await this.#worker.init(\n      dataDir,\n      this.#options,\n      Comlink.proxy(this.receiveNotification.bind(this)),\n    );\n    this.#ready = true;\n  }\n\n  get ready() {\n    return this.#ready;\n  }\n\n  get closed() {\n    return this.#closed;\n  }\n\n  async close() {\n    await this.#worker.close();\n    this.#closed = true;\n  }\n\n  async query<T>(\n    query: string,\n    params?: any[],\n    options?: QueryOptions,\n  ): Promise<Results<T>> {\n    return this.#worker.query(query, params, options) as Promise<Results<T>>;\n  }\n\n  async exec(query: string, options?: QueryOptions): Promise<Array<Results>> {\n    return this.#worker.exec(query, options);\n  }\n\n  async transaction<T>(callback: (tx: any) => Promise<T>) {\n    const callbackProxy = Comlink.proxy(callback);\n    return this.#worker.transaction(callbackProxy);\n  }\n\n  async execProtocol(\n    message: Uint8Array,\n  ): Promise<Array<[BackendMessage, Uint8Array]>> {\n    return this.#worker.execProtocol(message);\n  }\n\n  async listen(\n    channel: string,\n    callback: (payload: string) => void,\n  ): Promise<() => Promise<void>> {\n    if (!this.#notifyListeners.has(channel)) {\n      this.#notifyListeners.set(channel, new Set());\n    }\n    this.#notifyListeners.get(channel)?.add(callback);\n    await this.exec(`LISTEN ${channel}`);\n    return async () => {\n      await this.unlisten(channel, callback);\n    };\n  }\n\n  async unlisten(\n    channel: string,\n    callback?: (payload: string) => void,\n  ): Promise<void> {\n    if (callback) {\n      this.#notifyListeners.get(channel)?.delete(callback);\n    } else {\n      this.#notifyListeners.delete(channel);\n    }\n    if (this.#notifyListeners.get(channel)?.size === 0) {\n      // As we currently have a dedicated worker we can just unlisten\n      await this.exec(`UNLISTEN ${channel}`);\n    }\n  }\n\n  onNotification(callback: (channel: string, payload: string) => void) {\n    this.#globalNotifyListeners.add(callback);\n    return () => {\n      this.#globalNotifyListeners.delete(callback);\n    };\n  }\n\n  offNotification(callback: (channel: string, payload: string) => void) {\n    this.#globalNotifyListeners.delete(callback);\n  }\n\n  receiveNotification(channel: string, payload: string) {\n    const listeners = this.#notifyListeners.get(channel);\n    if (listeners) {\n      for (const listener of listeners) {\n        queueMicrotask(() => listener(payload));\n      }\n    }\n    for (const listener of this.#globalNotifyListeners) {\n      queueMicrotask(() => listener(channel, payload));\n    }\n  }\n}\n"],"mappings":"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","names":["init_buffer","_ready","_closed","_worker","_options","_notifyListeners","_globalNotifyListeners","_init","init_fn","PGliteWorker","dataDir","options","__privateAdd","dir","fsType","parseDataDir","__privateSet","wrap","__privateMethod","__privateGet","query","params","callback","callbackProxy","proxy","message","channel","payload","listeners","listener"]}