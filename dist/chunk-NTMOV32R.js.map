{"version":3,"sources":["../../../node_modules/.pnpm/pg-protocol@1.6.0_patch_hash=m6gmuhkj45op6ok66bc7av7i4y/node_modules/pg-protocol/src/messages.ts","../../../node_modules/.pnpm/pg-protocol@1.6.0_patch_hash=m6gmuhkj45op6ok66bc7av7i4y/node_modules/pg-protocol/src/buffer-writer.ts","../../../node_modules/.pnpm/pg-protocol@1.6.0_patch_hash=m6gmuhkj45op6ok66bc7av7i4y/node_modules/pg-protocol/src/serializer.ts","../../../node_modules/.pnpm/pg-protocol@1.6.0_patch_hash=m6gmuhkj45op6ok66bc7av7i4y/node_modules/pg-protocol/src/buffer-reader.ts","../src/polyfills/blank.ts","../../../node_modules/.pnpm/pg-protocol@1.6.0_patch_hash=m6gmuhkj45op6ok66bc7av7i4y/node_modules/pg-protocol/src/parser.ts","../../../node_modules/.pnpm/pg-protocol@1.6.0_patch_hash=m6gmuhkj45op6ok66bc7av7i4y/node_modules/pg-protocol/src/index.ts","../src/index.ts","../src/pglite.ts","../../../node_modules/.pnpm/async-mutex@0.4.1/node_modules/async-mutex/index.mjs","../src/event.ts","../src/parse.ts","../src/types.ts","../src/interface.ts"],"sourcesContent":["export type Mode = 'text' | 'binary'\n\nexport type MessageName =\n  | 'parseComplete'\n  | 'bindComplete'\n  | 'closeComplete'\n  | 'noData'\n  | 'portalSuspended'\n  | 'replicationStart'\n  | 'emptyQuery'\n  | 'copyDone'\n  | 'copyData'\n  | 'rowDescription'\n  | 'parameterDescription'\n  | 'parameterStatus'\n  | 'backendKeyData'\n  | 'notification'\n  | 'readyForQuery'\n  | 'commandComplete'\n  | 'dataRow'\n  | 'copyInResponse'\n  | 'copyOutResponse'\n  | 'authenticationOk'\n  | 'authenticationMD5Password'\n  | 'authenticationCleartextPassword'\n  | 'authenticationSASL'\n  | 'authenticationSASLContinue'\n  | 'authenticationSASLFinal'\n  | 'error'\n  | 'notice'\n\nexport interface BackendMessage {\n  name: MessageName\n  length: number\n}\n\nexport const parseComplete: BackendMessage = {\n  name: 'parseComplete',\n  length: 5,\n}\n\nexport const bindComplete: BackendMessage = {\n  name: 'bindComplete',\n  length: 5,\n}\n\nexport const closeComplete: BackendMessage = {\n  name: 'closeComplete',\n  length: 5,\n}\n\nexport const noData: BackendMessage = {\n  name: 'noData',\n  length: 5,\n}\n\nexport const portalSuspended: BackendMessage = {\n  name: 'portalSuspended',\n  length: 5,\n}\n\nexport const replicationStart: BackendMessage = {\n  name: 'replicationStart',\n  length: 4,\n}\n\nexport const emptyQuery: BackendMessage = {\n  name: 'emptyQuery',\n  length: 4,\n}\n\nexport const copyDone: BackendMessage = {\n  name: 'copyDone',\n  length: 4,\n}\n\ninterface NoticeOrError {\n  message: string | undefined\n  severity: string | undefined\n  code: string | undefined\n  detail: string | undefined\n  hint: string | undefined\n  position: string | undefined\n  internalPosition: string | undefined\n  internalQuery: string | undefined\n  where: string | undefined\n  schema: string | undefined\n  table: string | undefined\n  column: string | undefined\n  dataType: string | undefined\n  constraint: string | undefined\n  file: string | undefined\n  line: string | undefined\n  routine: string | undefined\n}\n\nexport class DatabaseError extends Error implements NoticeOrError {\n  public severity: string | undefined\n  public code: string | undefined\n  public detail: string | undefined\n  public hint: string | undefined\n  public position: string | undefined\n  public internalPosition: string | undefined\n  public internalQuery: string | undefined\n  public where: string | undefined\n  public schema: string | undefined\n  public table: string | undefined\n  public column: string | undefined\n  public dataType: string | undefined\n  public constraint: string | undefined\n  public file: string | undefined\n  public line: string | undefined\n  public routine: string | undefined\n  constructor(message: string, public readonly length: number, public readonly name: MessageName) {\n    super(message)\n  }\n}\n\nexport class CopyDataMessage {\n  public readonly name = 'copyData'\n  constructor(public readonly length: number, public readonly chunk: Buffer) {}\n}\n\nexport class CopyResponse {\n  public readonly columnTypes: number[]\n  constructor(\n    public readonly length: number,\n    public readonly name: MessageName,\n    public readonly binary: boolean,\n    columnCount: number\n  ) {\n    this.columnTypes = new Array(columnCount)\n  }\n}\n\nexport class Field {\n  constructor(\n    public readonly name: string,\n    public readonly tableID: number,\n    public readonly columnID: number,\n    public readonly dataTypeID: number,\n    public readonly dataTypeSize: number,\n    public readonly dataTypeModifier: number,\n    public readonly format: Mode\n  ) {}\n}\n\nexport class RowDescriptionMessage {\n  public readonly name: MessageName = 'rowDescription'\n  public readonly fields: Field[]\n  constructor(public readonly length: number, public readonly fieldCount: number) {\n    this.fields = new Array(this.fieldCount)\n  }\n}\n\nexport class ParameterDescriptionMessage {\n  public readonly name: MessageName = 'parameterDescription'\n  public readonly dataTypeIDs: number[]\n  constructor(public readonly length: number, public readonly parameterCount: number) {\n    this.dataTypeIDs = new Array(this.parameterCount)\n  }\n}\n\nexport class ParameterStatusMessage {\n  public readonly name: MessageName = 'parameterStatus'\n  constructor(\n    public readonly length: number,\n    public readonly parameterName: string,\n    public readonly parameterValue: string\n  ) {}\n}\n\nexport class AuthenticationMD5Password implements BackendMessage {\n  public readonly name: MessageName = 'authenticationMD5Password'\n  constructor(public readonly length: number, public readonly salt: Buffer) {}\n}\n\nexport class BackendKeyDataMessage {\n  public readonly name: MessageName = 'backendKeyData'\n  constructor(public readonly length: number, public readonly processID: number, public readonly secretKey: number) {}\n}\n\nexport class NotificationResponseMessage {\n  public readonly name: MessageName = 'notification'\n  constructor(\n    public readonly length: number,\n    public readonly processId: number,\n    public readonly channel: string,\n    public readonly payload: string\n  ) {}\n}\n\nexport class ReadyForQueryMessage {\n  public readonly name: MessageName = 'readyForQuery'\n  constructor(public readonly length: number, public readonly status: string) {}\n}\n\nexport class CommandCompleteMessage {\n  public readonly name: MessageName = 'commandComplete'\n  constructor(public readonly length: number, public readonly text: string) {}\n}\n\nexport class DataRowMessage {\n  public readonly fieldCount: number\n  public readonly name: MessageName = 'dataRow'\n  constructor(public length: number, public fields: any[]) {\n    this.fieldCount = fields.length\n  }\n}\n\nexport class NoticeMessage implements BackendMessage, NoticeOrError {\n  constructor(public readonly length: number, public readonly message: string | undefined) {}\n  public readonly name = 'notice'\n  public severity: string | undefined\n  public code: string | undefined\n  public detail: string | undefined\n  public hint: string | undefined\n  public position: string | undefined\n  public internalPosition: string | undefined\n  public internalQuery: string | undefined\n  public where: string | undefined\n  public schema: string | undefined\n  public table: string | undefined\n  public column: string | undefined\n  public dataType: string | undefined\n  public constraint: string | undefined\n  public file: string | undefined\n  public line: string | undefined\n  public routine: string | undefined\n}\n","//binary data writer tuned for encoding binary specific to the postgres binary protocol\n\nexport class Writer {\n  private buffer: Buffer\n  private offset: number = 5\n  private headerPosition: number = 0\n  constructor(private size = 256) {\n    this.buffer = Buffer.allocUnsafe(size)\n  }\n\n  private ensure(size: number): void {\n    var remaining = this.buffer.length - this.offset\n    if (remaining < size) {\n      var oldBuffer = this.buffer\n      // exponential growth factor of around ~ 1.5\n      // https://stackoverflow.com/questions/2269063/buffer-growth-strategy\n      var newSize = oldBuffer.length + (oldBuffer.length >> 1) + size\n      this.buffer = Buffer.allocUnsafe(newSize)\n      oldBuffer.copy(this.buffer)\n    }\n  }\n\n  public addInt32(num: number): Writer {\n    this.ensure(4)\n    this.buffer[this.offset++] = (num >>> 24) & 0xff\n    this.buffer[this.offset++] = (num >>> 16) & 0xff\n    this.buffer[this.offset++] = (num >>> 8) & 0xff\n    this.buffer[this.offset++] = (num >>> 0) & 0xff\n    return this\n  }\n\n  public addInt16(num: number): Writer {\n    this.ensure(2)\n    this.buffer[this.offset++] = (num >>> 8) & 0xff\n    this.buffer[this.offset++] = (num >>> 0) & 0xff\n    return this\n  }\n\n  public addCString(string: string): Writer {\n    if (!string) {\n      this.ensure(1)\n    } else {\n      var len = Buffer.byteLength(string)\n      this.ensure(len + 1) // +1 for null terminator\n      this.buffer.write(string, this.offset, 'utf-8')\n      this.offset += len\n    }\n\n    this.buffer[this.offset++] = 0 // null terminator\n    return this\n  }\n\n  public addString(string: string = ''): Writer {\n    var len = Buffer.byteLength(string)\n    this.ensure(len)\n    this.buffer.write(string, this.offset)\n    this.offset += len\n    return this\n  }\n\n  public add(otherBuffer: Buffer): Writer {\n    this.ensure(otherBuffer.length)\n    otherBuffer.copy(this.buffer, this.offset)\n    this.offset += otherBuffer.length\n    return this\n  }\n\n  private join(code?: number): Buffer {\n    if (code) {\n      this.buffer[this.headerPosition] = code\n      //length is everything in this packet minus the code\n      const length = this.offset - (this.headerPosition + 1)\n      this.buffer.writeInt32BE(length, this.headerPosition + 1)\n    }\n    return this.buffer.slice(code ? 0 : 5, this.offset)\n  }\n\n  public flush(code?: number): Buffer {\n    var result = this.join(code)\n    this.offset = 5\n    this.headerPosition = 0\n    this.buffer = Buffer.allocUnsafe(this.size)\n    return result\n  }\n}\n","import { Writer } from './buffer-writer'\n\nconst enum code {\n  startup = 0x70,\n  query = 0x51,\n  parse = 0x50,\n  bind = 0x42,\n  execute = 0x45,\n  flush = 0x48,\n  sync = 0x53,\n  end = 0x58,\n  close = 0x43,\n  describe = 0x44,\n  copyFromChunk = 0x64,\n  copyDone = 0x63,\n  copyFail = 0x66,\n}\n\nconst writer = new Writer()\n\nconst startup = (opts: Record<string, string>): Buffer => {\n  // protocol version\n  writer.addInt16(3).addInt16(0)\n  for (const key of Object.keys(opts)) {\n    writer.addCString(key).addCString(opts[key])\n  }\n\n  writer.addCString('client_encoding').addCString('UTF8')\n\n  var bodyBuffer = writer.addCString('').flush()\n  // this message is sent without a code\n\n  var length = bodyBuffer.length + 4\n\n  return new Writer().addInt32(length).add(bodyBuffer).flush()\n}\n\nconst requestSsl = (): Buffer => {\n  const response = Buffer.allocUnsafe(8)\n  response.writeInt32BE(8, 0)\n  response.writeInt32BE(80877103, 4)\n  return response\n}\n\nconst password = (password: string): Buffer => {\n  return writer.addCString(password).flush(code.startup)\n}\n\nconst sendSASLInitialResponseMessage = function (mechanism: string, initialResponse: string): Buffer {\n  // 0x70 = 'p'\n  writer.addCString(mechanism).addInt32(Buffer.byteLength(initialResponse)).addString(initialResponse)\n\n  return writer.flush(code.startup)\n}\n\nconst sendSCRAMClientFinalMessage = function (additionalData: string): Buffer {\n  return writer.addString(additionalData).flush(code.startup)\n}\n\nconst query = (text: string): Buffer => {\n  return writer.addCString(text).flush(code.query)\n}\n\ntype ParseOpts = {\n  name?: string\n  types?: number[]\n  text: string\n}\n\nconst emptyArray: any[] = []\n\nconst parse = (query: ParseOpts): Buffer => {\n  // expect something like this:\n  // { name: 'queryName',\n  //   text: 'select * from blah',\n  //   types: ['int8', 'bool'] }\n\n  // normalize missing query names to allow for null\n  const name = query.name || ''\n  if (name.length > 63) {\n    /* eslint-disable no-console */\n    console.error('Warning! Postgres only supports 63 characters for query names.')\n    console.error('You supplied %s (%s)', name, name.length)\n    console.error('This can cause conflicts and silent errors executing queries')\n    /* eslint-enable no-console */\n  }\n\n  const types = query.types || emptyArray\n\n  var len = types.length\n\n  var buffer = writer\n    .addCString(name) // name of query\n    .addCString(query.text) // actual query text\n    .addInt16(len)\n\n  for (var i = 0; i < len; i++) {\n    buffer.addInt32(types[i])\n  }\n\n  return writer.flush(code.parse)\n}\n\ntype ValueMapper = (param: any, index: number) => any\n\ntype BindOpts = {\n  portal?: string\n  binary?: boolean\n  statement?: string\n  values?: any[]\n  // optional map from JS value to postgres value per parameter\n  valueMapper?: ValueMapper\n}\n\nconst paramWriter = new Writer()\n\n// make this a const enum so typescript will inline the value\nconst enum ParamType {\n  STRING = 0,\n  BINARY = 1,\n}\n\nconst writeValues = function (values: any[], valueMapper?: ValueMapper): void {\n  for (let i = 0; i < values.length; i++) {\n    const mappedVal = valueMapper ? valueMapper(values[i], i) : values[i]\n    if (mappedVal == null) {\n      // add the param type (string) to the writer\n      writer.addInt16(ParamType.STRING)\n      // write -1 to the param writer to indicate null\n      paramWriter.addInt32(-1)\n    } else if (mappedVal instanceof Buffer) {\n      // add the param type (binary) to the writer\n      writer.addInt16(ParamType.BINARY)\n      // add the buffer to the param writer\n      paramWriter.addInt32(mappedVal.length)\n      paramWriter.add(mappedVal)\n    } else {\n      // add the param type (string) to the writer\n      writer.addInt16(ParamType.STRING)\n      paramWriter.addInt32(Buffer.byteLength(mappedVal))\n      paramWriter.addString(mappedVal)\n    }\n  }\n}\n\nconst bind = (config: BindOpts = {}): Buffer => {\n  // normalize config\n  const portal = config.portal || ''\n  const statement = config.statement || ''\n  const binary = config.binary || false\n  const values = config.values || emptyArray\n  const len = values.length\n\n  writer.addCString(portal).addCString(statement)\n  writer.addInt16(len)\n\n  writeValues(values, config.valueMapper)\n\n  writer.addInt16(len)\n  writer.add(paramWriter.flush())\n\n  // format code\n  writer.addInt16(binary ? ParamType.BINARY : ParamType.STRING)\n  return writer.flush(code.bind)\n}\n\ntype ExecOpts = {\n  portal?: string\n  rows?: number\n}\n\nconst emptyExecute = Buffer.from([code.execute, 0x00, 0x00, 0x00, 0x09, 0x00, 0x00, 0x00, 0x00, 0x00])\n\nconst execute = (config?: ExecOpts): Buffer => {\n  // this is the happy path for most queries\n  if (!config || (!config.portal && !config.rows)) {\n    return emptyExecute\n  }\n\n  const portal = config.portal || ''\n  const rows = config.rows || 0\n\n  const portalLength = Buffer.byteLength(portal)\n  const len = 4 + portalLength + 1 + 4\n  // one extra bit for code\n  const buff = Buffer.allocUnsafe(1 + len)\n  buff[0] = code.execute\n  buff.writeInt32BE(len, 1)\n  buff.write(portal, 5, 'utf-8')\n  buff[portalLength + 5] = 0 // null terminate portal cString\n  buff.writeUInt32BE(rows, buff.length - 4)\n  return buff\n}\n\nconst cancel = (processID: number, secretKey: number): Buffer => {\n  const buffer = Buffer.allocUnsafe(16)\n  buffer.writeInt32BE(16, 0)\n  buffer.writeInt16BE(1234, 4)\n  buffer.writeInt16BE(5678, 6)\n  buffer.writeInt32BE(processID, 8)\n  buffer.writeInt32BE(secretKey, 12)\n  return buffer\n}\n\ntype PortalOpts = {\n  type: 'S' | 'P'\n  name?: string\n}\n\nconst cstringMessage = (code: code, string: string): Buffer => {\n  const stringLen = Buffer.byteLength(string)\n  const len = 4 + stringLen + 1\n  // one extra bit for code\n  const buffer = Buffer.allocUnsafe(1 + len)\n  buffer[0] = code\n  buffer.writeInt32BE(len, 1)\n  buffer.write(string, 5, 'utf-8')\n  buffer[len] = 0 // null terminate cString\n  return buffer\n}\n\nconst emptyDescribePortal = writer.addCString('P').flush(code.describe)\nconst emptyDescribeStatement = writer.addCString('S').flush(code.describe)\n\nconst describe = (msg: PortalOpts): Buffer => {\n  return msg.name\n    ? cstringMessage(code.describe, `${msg.type}${msg.name || ''}`)\n    : msg.type === 'P'\n    ? emptyDescribePortal\n    : emptyDescribeStatement\n}\n\nconst close = (msg: PortalOpts): Buffer => {\n  const text = `${msg.type}${msg.name || ''}`\n  return cstringMessage(code.close, text)\n}\n\nconst copyData = (chunk: Buffer): Buffer => {\n  return writer.add(chunk).flush(code.copyFromChunk)\n}\n\nconst copyFail = (message: string): Buffer => {\n  return cstringMessage(code.copyFail, message)\n}\n\nconst codeOnlyBuffer = (code: code): Buffer => Buffer.from([code, 0x00, 0x00, 0x00, 0x04])\n\nconst flushBuffer = codeOnlyBuffer(code.flush)\nconst syncBuffer = codeOnlyBuffer(code.sync)\nconst endBuffer = codeOnlyBuffer(code.end)\nconst copyDoneBuffer = codeOnlyBuffer(code.copyDone)\n\nconst serialize = {\n  startup,\n  password,\n  requestSsl,\n  sendSASLInitialResponseMessage,\n  sendSCRAMClientFinalMessage,\n  query,\n  parse,\n  bind,\n  execute,\n  describe,\n  close,\n  flush: () => flushBuffer,\n  sync: () => syncBuffer,\n  end: () => endBuffer,\n  copyData,\n  copyDone: () => copyDoneBuffer,\n  copyFail,\n  cancel,\n}\n\nexport { serialize }\n","const emptyBuffer = Buffer.allocUnsafe(0)\n\nexport class BufferReader {\n  private buffer: Buffer = emptyBuffer\n\n  // TODO(bmc): support non-utf8 encoding?\n  private encoding = 'utf-8' as const\n\n  constructor(private offset: number = 0) {}\n\n  public setBuffer(offset: number, buffer: Buffer): void {\n    this.offset = offset\n    this.buffer = buffer\n  }\n\n  public int16(): number {\n    const result = this.buffer.readInt16BE(this.offset)\n    this.offset += 2\n    return result\n  }\n\n  public byte(): number {\n    const result = this.buffer[this.offset]\n    this.offset++\n    return result\n  }\n\n  public int32(): number {\n    const result = this.buffer.readInt32BE(this.offset)\n    this.offset += 4\n    return result\n  }\n\n  public string(length: number): string {\n    const result = this.buffer.toString(this.encoding, this.offset, this.offset + length)\n    this.offset += length\n    return result\n  }\n\n  public cstring(): string {\n    const start = this.offset\n    let end = start\n    while (this.buffer[end++] !== 0) {}\n    this.offset = end\n    return this.buffer.toString(this.encoding, start, end - 1)\n  }\n\n  public bytes(length: number): Buffer {\n    const result = this.buffer.slice(this.offset, this.offset + length)\n    this.offset += length\n    return result\n  }\n}\n","// Used in tsup.config.ts to replace the `assert` module with a blank file.\n","import { TransformOptions } from 'stream'\nimport {\n  Mode,\n  bindComplete,\n  parseComplete,\n  closeComplete,\n  noData,\n  portalSuspended,\n  copyDone,\n  replicationStart,\n  emptyQuery,\n  ReadyForQueryMessage,\n  CommandCompleteMessage,\n  CopyDataMessage,\n  CopyResponse,\n  NotificationResponseMessage,\n  RowDescriptionMessage,\n  ParameterDescriptionMessage,\n  Field,\n  DataRowMessage,\n  ParameterStatusMessage,\n  BackendKeyDataMessage,\n  DatabaseError,\n  BackendMessage,\n  MessageName,\n  AuthenticationMD5Password,\n  NoticeMessage,\n} from './messages'\nimport { BufferReader } from './buffer-reader'\nimport assert from 'assert'\n\n// every message is prefixed with a single bye\nconst CODE_LENGTH = 1\n// every message has an int32 length which includes itself but does\n// NOT include the code in the length\nconst LEN_LENGTH = 4\n\nconst HEADER_LENGTH = CODE_LENGTH + LEN_LENGTH\n\nexport type Packet = {\n  code: number\n  packet: Buffer\n}\n\nconst emptyBuffer = Buffer.allocUnsafe(0)\n\ntype StreamOptions = TransformOptions & {\n  mode: Mode\n}\n\nconst enum MessageCodes {\n  DataRow = 0x44, // D\n  ParseComplete = 0x31, // 1\n  BindComplete = 0x32, // 2\n  CloseComplete = 0x33, // 3\n  CommandComplete = 0x43, // C\n  ReadyForQuery = 0x5a, // Z\n  NoData = 0x6e, // n\n  NotificationResponse = 0x41, // A\n  AuthenticationResponse = 0x52, // R\n  ParameterStatus = 0x53, // S\n  BackendKeyData = 0x4b, // K\n  ErrorMessage = 0x45, // E\n  NoticeMessage = 0x4e, // N\n  RowDescriptionMessage = 0x54, // T\n  ParameterDescriptionMessage = 0x74, // t\n  PortalSuspended = 0x73, // s\n  ReplicationStart = 0x57, // W\n  EmptyQuery = 0x49, // I\n  CopyIn = 0x47, // G\n  CopyOut = 0x48, // H\n  CopyDone = 0x63, // c\n  CopyData = 0x64, // d\n}\n\nexport type MessageCallback = (msg: BackendMessage) => void\n\nexport class Parser {\n  private buffer: Buffer = emptyBuffer\n  private bufferLength: number = 0\n  private bufferOffset: number = 0\n  private reader = new BufferReader()\n  private mode: Mode\n\n  constructor(opts?: StreamOptions) {\n    if (opts?.mode === 'binary') {\n      throw new Error('Binary mode not supported yet')\n    }\n    this.mode = opts?.mode || 'text'\n  }\n\n  public parse(buffer: Buffer, callback: MessageCallback) {\n    this.mergeBuffer(buffer)\n    const bufferFullLength = this.bufferOffset + this.bufferLength\n    let offset = this.bufferOffset\n    while (offset + HEADER_LENGTH <= bufferFullLength) {\n      // code is 1 byte long - it identifies the message type\n      const code = this.buffer[offset]\n      // length is 1 Uint32BE - it is the length of the message EXCLUDING the code\n      const length = this.buffer.readUInt32BE(offset + CODE_LENGTH)\n      const fullMessageLength = CODE_LENGTH + length\n      if (fullMessageLength + offset <= bufferFullLength) {\n        const message = this.handlePacket(offset + HEADER_LENGTH, code, length, this.buffer)\n        callback(message)\n        offset += fullMessageLength\n      } else {\n        break\n      }\n    }\n    if (offset === bufferFullLength) {\n      // No more use for the buffer\n      this.buffer = emptyBuffer\n      this.bufferLength = 0\n      this.bufferOffset = 0\n    } else {\n      // Adjust the cursors of remainingBuffer\n      this.bufferLength = bufferFullLength - offset\n      this.bufferOffset = offset\n    }\n  }\n\n  private mergeBuffer(buffer: Buffer): void {\n    if (this.bufferLength > 0) {\n      const newLength = this.bufferLength + buffer.byteLength\n      const newFullLength = newLength + this.bufferOffset\n      if (newFullLength > this.buffer.byteLength) {\n        // We can't concat the new buffer with the remaining one\n        let newBuffer: Buffer\n        if (newLength <= this.buffer.byteLength && this.bufferOffset >= this.bufferLength) {\n          // We can move the relevant part to the beginning of the buffer instead of allocating a new buffer\n          newBuffer = this.buffer\n        } else {\n          // Allocate a new larger buffer\n          let newBufferLength = this.buffer.byteLength * 2\n          while (newLength >= newBufferLength) {\n            newBufferLength *= 2\n          }\n          newBuffer = Buffer.allocUnsafe(newBufferLength)\n        }\n        // Move the remaining buffer to the new one\n        this.buffer.copy(newBuffer, 0, this.bufferOffset, this.bufferOffset + this.bufferLength)\n        this.buffer = newBuffer\n        this.bufferOffset = 0\n      }\n      // Concat the new buffer with the remaining one\n      buffer.copy(this.buffer, this.bufferOffset + this.bufferLength)\n      this.bufferLength = newLength\n    } else {\n      this.buffer = buffer\n      this.bufferOffset = 0\n      this.bufferLength = buffer.byteLength\n    }\n  }\n\n  private handlePacket(offset: number, code: number, length: number, bytes: Buffer): BackendMessage {\n    switch (code) {\n      case MessageCodes.BindComplete:\n        return bindComplete\n      case MessageCodes.ParseComplete:\n        return parseComplete\n      case MessageCodes.CloseComplete:\n        return closeComplete\n      case MessageCodes.NoData:\n        return noData\n      case MessageCodes.PortalSuspended:\n        return portalSuspended\n      case MessageCodes.CopyDone:\n        return copyDone\n      case MessageCodes.ReplicationStart:\n        return replicationStart\n      case MessageCodes.EmptyQuery:\n        return emptyQuery\n      case MessageCodes.DataRow:\n        return this.parseDataRowMessage(offset, length, bytes)\n      case MessageCodes.CommandComplete:\n        return this.parseCommandCompleteMessage(offset, length, bytes)\n      case MessageCodes.ReadyForQuery:\n        return this.parseReadyForQueryMessage(offset, length, bytes)\n      case MessageCodes.NotificationResponse:\n        return this.parseNotificationMessage(offset, length, bytes)\n      case MessageCodes.AuthenticationResponse:\n        return this.parseAuthenticationResponse(offset, length, bytes)\n      case MessageCodes.ParameterStatus:\n        return this.parseParameterStatusMessage(offset, length, bytes)\n      case MessageCodes.BackendKeyData:\n        return this.parseBackendKeyData(offset, length, bytes)\n      case MessageCodes.ErrorMessage:\n        return this.parseErrorMessage(offset, length, bytes, 'error')\n      case MessageCodes.NoticeMessage:\n        return this.parseErrorMessage(offset, length, bytes, 'notice')\n      case MessageCodes.RowDescriptionMessage:\n        return this.parseRowDescriptionMessage(offset, length, bytes)\n      case MessageCodes.ParameterDescriptionMessage:\n        return this.parseParameterDescriptionMessage(offset, length, bytes)\n      case MessageCodes.CopyIn:\n        return this.parseCopyInMessage(offset, length, bytes)\n      case MessageCodes.CopyOut:\n        return this.parseCopyOutMessage(offset, length, bytes)\n      case MessageCodes.CopyData:\n        return this.parseCopyData(offset, length, bytes)\n      default:\n        assert.fail(`unknown message code: ${code.toString(16)}`)\n    }\n  }\n\n  private parseReadyForQueryMessage(offset: number, length: number, bytes: Buffer) {\n    this.reader.setBuffer(offset, bytes)\n    const status = this.reader.string(1)\n    return new ReadyForQueryMessage(length, status)\n  }\n\n  private parseCommandCompleteMessage(offset: number, length: number, bytes: Buffer) {\n    this.reader.setBuffer(offset, bytes)\n    const text = this.reader.cstring()\n    return new CommandCompleteMessage(length, text)\n  }\n\n  private parseCopyData(offset: number, length: number, bytes: Buffer) {\n    const chunk = bytes.slice(offset, offset + (length - 4))\n    return new CopyDataMessage(length, chunk)\n  }\n\n  private parseCopyInMessage(offset: number, length: number, bytes: Buffer) {\n    return this.parseCopyMessage(offset, length, bytes, 'copyInResponse')\n  }\n\n  private parseCopyOutMessage(offset: number, length: number, bytes: Buffer) {\n    return this.parseCopyMessage(offset, length, bytes, 'copyOutResponse')\n  }\n\n  private parseCopyMessage(offset: number, length: number, bytes: Buffer, messageName: MessageName) {\n    this.reader.setBuffer(offset, bytes)\n    const isBinary = this.reader.byte() !== 0\n    const columnCount = this.reader.int16()\n    const message = new CopyResponse(length, messageName, isBinary, columnCount)\n    for (let i = 0; i < columnCount; i++) {\n      message.columnTypes[i] = this.reader.int16()\n    }\n    return message\n  }\n\n  private parseNotificationMessage(offset: number, length: number, bytes: Buffer) {\n    this.reader.setBuffer(offset, bytes)\n    const processId = this.reader.int32()\n    const channel = this.reader.cstring()\n    const payload = this.reader.cstring()\n    return new NotificationResponseMessage(length, processId, channel, payload)\n  }\n\n  private parseRowDescriptionMessage(offset: number, length: number, bytes: Buffer) {\n    this.reader.setBuffer(offset, bytes)\n    const fieldCount = this.reader.int16()\n    const message = new RowDescriptionMessage(length, fieldCount)\n    for (let i = 0; i < fieldCount; i++) {\n      message.fields[i] = this.parseField()\n    }\n    return message\n  }\n\n  private parseField(): Field {\n    const name = this.reader.cstring()\n    const tableID = this.reader.int32()\n    const columnID = this.reader.int16()\n    const dataTypeID = this.reader.int32()\n    const dataTypeSize = this.reader.int16()\n    const dataTypeModifier = this.reader.int32()\n    const mode = this.reader.int16() === 0 ? 'text' : 'binary'\n    return new Field(name, tableID, columnID, dataTypeID, dataTypeSize, dataTypeModifier, mode)\n  }\n\n  private parseParameterDescriptionMessage(offset: number, length: number, bytes: Buffer) {\n    this.reader.setBuffer(offset, bytes)\n    const parameterCount = this.reader.int16()\n    const message = new ParameterDescriptionMessage(length, parameterCount)\n    for (let i = 0; i < parameterCount; i++) {\n      message.dataTypeIDs[i] = this.reader.int32()\n    }\n    return message\n  }\n\n  private parseDataRowMessage(offset: number, length: number, bytes: Buffer) {\n    this.reader.setBuffer(offset, bytes)\n    const fieldCount = this.reader.int16()\n    const fields: any[] = new Array(fieldCount)\n    for (let i = 0; i < fieldCount; i++) {\n      const len = this.reader.int32()\n      // a -1 for length means the value of the field is null\n      fields[i] = len === -1 ? null : this.reader.string(len)\n    }\n    return new DataRowMessage(length, fields)\n  }\n\n  private parseParameterStatusMessage(offset: number, length: number, bytes: Buffer) {\n    this.reader.setBuffer(offset, bytes)\n    const name = this.reader.cstring()\n    const value = this.reader.cstring()\n    return new ParameterStatusMessage(length, name, value)\n  }\n\n  private parseBackendKeyData(offset: number, length: number, bytes: Buffer) {\n    this.reader.setBuffer(offset, bytes)\n    const processID = this.reader.int32()\n    const secretKey = this.reader.int32()\n    return new BackendKeyDataMessage(length, processID, secretKey)\n  }\n\n  public parseAuthenticationResponse(offset: number, length: number, bytes: Buffer) {\n    this.reader.setBuffer(offset, bytes)\n    const code = this.reader.int32()\n    // TODO(bmc): maybe better types here\n    const message: BackendMessage & any = {\n      name: 'authenticationOk',\n      length,\n    }\n\n    switch (code) {\n      case 0: // AuthenticationOk\n        break\n      case 3: // AuthenticationCleartextPassword\n        if (message.length === 8) {\n          message.name = 'authenticationCleartextPassword'\n        }\n        break\n      case 5: // AuthenticationMD5Password\n        if (message.length === 12) {\n          message.name = 'authenticationMD5Password'\n          const salt = this.reader.bytes(4)\n          return new AuthenticationMD5Password(length, salt)\n        }\n        break\n      case 10: // AuthenticationSASL\n        message.name = 'authenticationSASL'\n        message.mechanisms = []\n        let mechanism: string\n        do {\n          mechanism = this.reader.cstring()\n\n          if (mechanism) {\n            message.mechanisms.push(mechanism)\n          }\n        } while (mechanism)\n        break\n      case 11: // AuthenticationSASLContinue\n        message.name = 'authenticationSASLContinue'\n        message.data = this.reader.string(length - 8)\n        break\n      case 12: // AuthenticationSASLFinal\n        message.name = 'authenticationSASLFinal'\n        message.data = this.reader.string(length - 8)\n        break\n      default:\n        throw new Error('Unknown authenticationOk message type ' + code)\n    }\n    return message\n  }\n\n  private parseErrorMessage(offset: number, length: number, bytes: Buffer, name: MessageName) {\n    this.reader.setBuffer(offset, bytes)\n    const fields: Record<string, string> = {}\n    let fieldType = this.reader.string(1)\n    while (fieldType !== '\\0') {\n      fields[fieldType] = this.reader.cstring()\n      fieldType = this.reader.string(1)\n    }\n\n    const messageValue = fields.M\n\n    const message =\n      name === 'notice' ? new NoticeMessage(length, messageValue) : new DatabaseError(messageValue, length, name)\n\n    message.severity = fields.S\n    message.code = fields.C\n    message.detail = fields.D\n    message.hint = fields.H\n    message.position = fields.P\n    message.internalPosition = fields.p\n    message.internalQuery = fields.q\n    message.where = fields.W\n    message.schema = fields.s\n    message.table = fields.t\n    message.column = fields.c\n    message.dataType = fields.d\n    message.constraint = fields.n\n    message.file = fields.F\n    message.line = fields.L\n    message.routine = fields.R\n    return message\n  }\n}\n","import { BackendMessage, DatabaseError } from './messages'\nimport { serialize } from './serializer'\nimport { Parser, MessageCallback } from './parser'\n\nexport function parse(stream: NodeJS.ReadableStream, callback: MessageCallback): Promise<void> {\n  const parser = new Parser()\n  stream.on('data', (buffer: Buffer) => parser.parse(buffer, callback))\n  return new Promise((resolve) => stream.on('end', () => resolve()))\n}\n\nexport { serialize, DatabaseError }\n","export * from \"./pglite.js\";\nexport * from \"./interface.js\";\nexport * as types from \"./types.js\";\nexport * as parse from \"./parse.js\";\nexport * as messages from \"pg-protocol/dist/messages.js\";\nexport * as protocol from \"pg-protocol/dist/index.js\";\nexport { Mutex } from \"async-mutex\";\n","import { Mutex } from \"async-mutex\";\nimport EmPostgresFactory, { EmscriptenModule, type EmPostgres } from \"../release/postgres.js\";\nimport { type Filesystem, parseDataDir, loadFs } from \"./fs/index.js\";\nimport { fileExists, getExtensionControlFile, getExtensionSqlScript, getExtensionVersionFromControlFile, makeLocateFile } from \"./utils.js\";\nimport { PGEvent } from \"./event.js\";\nimport { parseResults } from \"./parse.js\";\nimport { serializeType } from \"./types.js\";\nimport type {\n  DebugLevel,\n  PGliteOptions,\n  PGliteInterface,\n  Results,\n  Transaction,\n  QueryOptions,\n  ExecProtocolOptions,\n  PGliteInterfaceExtensions,\n  Extensions,\n  Extension,\n} from \"./interface.js\";\n\n// Importing the source as the built version is not ESM compatible\nimport { serialize } from \"pg-protocol/dist/index.js\";\nimport { Parser } from \"pg-protocol/dist/parser.js\";\nimport {\n  BackendMessage,\n  DatabaseError,\n  NoticeMessage,\n  CommandCompleteMessage,\n  NotificationResponseMessage,\n} from \"pg-protocol/dist/messages.js\";\n\nexport class PGlite implements PGliteInterface {\n  fs?: Filesystem;\n  protected emp?: any;\n\n  #extensions: Extensions;\n  #initStarted = false;\n  #ready = false;\n  #eventTarget: EventTarget;\n  #closing = false;\n  #closed = false;\n  #inTransaction = false;\n  #relaxedDurability = false;\n  #extensionsClose: Array<() => Promise<void>> = [];\n\n  #resultAccumulator: Uint8Array[] = [];\n\n  readonly waitReady: Promise<void>;\n\n  #executeMutex = new Mutex();\n  #queryMutex = new Mutex();\n  #transactionMutex = new Mutex();\n  #fsSyncMutex = new Mutex();\n  #fsSyncScheduled = false;\n\n  readonly debug: DebugLevel = 0;\n\n  #parser = new Parser();\n\n  // These are the current ArrayBuffer that is being read or written to\n  // during a query, such as COPY FROM or COPY TO.\n  #queryReadBuffer?: ArrayBuffer;\n  #queryWriteChunks?: Uint8Array[];\n\n  #notifyListeners = new Map<string, Set<(payload: string) => void>>();\n  #globalNotifyListeners = new Set<\n    (channel: string, payload: string) => void\n  >();\n\n  /**\n   * Create a new PGlite instance\n   * @param dataDir The directory to store the database files\n   *                Prefix with idb:// to use indexeddb filesystem in the browser\n   *                Use memory:// to use in-memory filesystem\n   * @param options Optional options\n   */\n  constructor(dataDir?: string, options?: PGliteOptions);\n\n  /**\n   * Create a new PGlite instance\n   * @param options PGlite options including the data directory\n   */\n  constructor(options?: PGliteOptions);\n\n  constructor(\n    dataDirOrPGliteOptions: string | PGliteOptions = {},\n    options: PGliteOptions = {},\n  ) {\n    if (typeof dataDirOrPGliteOptions === \"string\") {\n      options = {\n        dataDir: dataDirOrPGliteOptions,\n        ...options,\n      };\n    } else {\n      options = dataDirOrPGliteOptions;\n    }\n\n    // Enable debug logging if requested\n    if (options?.debug !== undefined) {\n      this.debug = options.debug;\n    }\n\n    // Enable relaxed durability if requested\n    if (options?.relaxedDurability !== undefined) {\n      this.#relaxedDurability = options.relaxedDurability;\n    }\n\n    // Create an event target to handle events from the emscripten module\n    this.#eventTarget = new EventTarget();\n\n    // Listen for result events from the emscripten module and accumulate them\n    this.#eventTarget.addEventListener(\"result\", async (e: any) => {\n      this.#resultAccumulator.push(e.detail);\n    });\n\n    // Save the extensions for later use\n    this.#extensions = options.extensions ?? {};\n\n    // Initialize the database, and store the promise so we can wait for it to be ready\n    this.waitReady = this.#init(options ?? {});\n  }\n\n  /**\n   * Initialize the database\n   * @returns A promise that resolves when the database is ready\n   */\n  async #init(options: PGliteOptions) {\n    if (options.fs) {\n      this.fs = options.fs;\n    } else {\n      const { dataDir, fsType } = parseDataDir(options.dataDir);\n      this.fs = await loadFs(dataDir, fsType);\n    }\n\n    const extensionInitFns: Array<() => Promise<void>> = [];\n    let firstRun = false;\n    await new Promise<void>(async (resolve, reject) => {\n      if (this.#initStarted) {\n        throw new Error(\"Already initializing\");\n      }\n      this.#initStarted = true;\n\n      // Initialize the filesystem\n      // returns true if this is the first run, we then need to perform\n      // additional setup steps at the end of the init.\n      firstRun = await this.fs!.init(this.debug);\n\n      let emscriptenOpts: Partial<EmPostgres> = {\n        arguments: [\n          \"--single\", // Single user mode\n          \"-F\", // Disable fsync (TODO: Only for in-memory mode?)\n          \"-O\", // Allow the structure of system tables to be modified. This is used by initdb\n          \"-j\", // Single use mode - Use semicolon followed by two newlines, rather than just newline, as the command entry terminator.\n          \"-c\", // Set parameter\n          \"search_path=pg_catalog\",\n          \"-c\",\n          \"dynamic_shared_memory_type=mmap\",\n          \"-c\",\n          \"max_prepared_transactions=10\",\n          // Debug level\n          ...(this.debug ? [\"-d\", this.debug.toString()] : []),\n          \"-D\", // Data directory\n          \"/pgdata\",\n          \"template1\",\n        ],\n        locateFile: await makeLocateFile(),\n        ...(this.debug > 0\n          ? { print: console.info, printErr: console.error }\n          : { print: () => { }, printErr: () => { } }),\n        preRun: [\n          (mod: any) => {\n            // Register /dev/blob device\n            // This is used to read and write blobs when used in COPY TO/FROM\n            // e.g. COPY mytable TO '/dev/blob' WITH (FORMAT binary)\n            // The data is returned by the query as a `blob` property in the results\n            const devId = mod.FS.makedev(64, 0);\n            let callCounter = 0;\n            const devOpt = {\n              open: (stream: any) => { },\n              close: (stream: any) => { },\n              read: (\n                stream: any,\n                buffer: Uint8Array,\n                offset: number,\n                length: number,\n                position: number,\n              ) => {\n                const buf = this.#queryReadBuffer;\n                if (!buf) {\n                  throw new Error(\"No File or Blob provided to read from\");\n                }\n                const contents = new Uint8Array(buf);\n                if (position >= contents.length) return 0;\n                const size = Math.min(contents.length - position, length);\n                for (let i = 0; i < size; i++) {\n                  buffer[offset + i] = contents[position + i];\n                }\n                return size;\n              },\n              write: (\n                stream: any,\n                buffer: Uint8Array,\n                offset: number,\n                length: number,\n                position: number,\n              ) => {\n                callCounter++;\n                this.#queryWriteChunks ??= [];\n                this.#queryWriteChunks.push(\n                  buffer.slice(offset, offset + length),\n                );\n                return length;\n              },\n              llseek: (stream: any, offset: number, whence: number) => {\n                throw new Error(\"Cannot seek /dev/blob\");\n              },\n            };\n            mod.FS.registerDevice(devId, devOpt);\n            mod.FS.mkdev(\"/dev/blob\", devId);\n          },\n        ],\n        onRuntimeInitialized: async (Module: EmPostgres) => {\n          // handle extensions that shuould be opened with dlopen\n          await Promise.all(Object.entries(this.#extensions).map(([extName, ext]) => {\n            if (!ext.pathOrUrl) return;\n            return this.#_addExtension(Module, extName, ext);\n          }));\n          await this.fs!.initialSyncFs(Module.FS);\n          this.#ready = true;\n          resolve();\n        },\n        eventTarget: this.#eventTarget,\n        Event: PGEvent,\n      };\n\n      // Setup extensions\n      for (const [extName, ext] of Object.entries(this.#extensions)) {\n        if (ext.pathOrUrl) continue;\n        const extRet = await ext.setup(this, emscriptenOpts);\n        if (extRet.emscriptenOpts) {\n          emscriptenOpts = extRet.emscriptenOpts;\n        }\n        if (extRet.namespaceObj) {\n          (this as any)[extName] = extRet.namespaceObj;\n        }\n        if (extRet.init) {\n          extensionInitFns.push(extRet.init);\n        }\n        if (extRet.close) {\n          this.#extensionsClose.push(extRet.close);\n        }\n      }\n\n      emscriptenOpts = await this.fs!.emscriptenOpts(emscriptenOpts);\n      const emp = await EmPostgresFactory(emscriptenOpts);\n      this.emp = emp;\n    });\n\n    if (firstRun) {\n      await this.#firstRun();\n    }\n    await this.#runExec(`\n      SET search_path TO public;\n    `);\n\n    // Init extensions\n    for (const initFn of extensionInitFns) {\n      await initFn();\n    }\n  }\n\n  async addExtension(extName: string, extension: Extension) {\n    if (!this.emp) {\n      throw new Error('Can not add extensions before wasm module initialization');\n    }\n\n    return this.#_addExtension(this.emp, extName, extension);\n  }\n\n  async #_addExtension(module: EmPostgres, extName: string, extension: Extension) {\n\n    const pgControlPath = `/usr/local/pgsql/share/extension/${extName}.control`;\n\n    if (fileExists(module.FS, pgControlPath)) {\n      return;\n    }\n\n    const controlFileContent = await getExtensionControlFile(extension, extName);\n\n    const extensionVersion = getExtensionVersionFromControlFile(controlFileContent);\n    if (!extensionVersion) {\n      throw new Error(`Invalid control file for extension ${extName}`);\n    }\n\n    const sqlFileName = `${extName}--${extensionVersion}.sql`;\n    const sqlFilePath = `${extension.pathOrUrl}/${sqlFileName}`;\n\n    const sqlFileContent = await getExtensionSqlScript(extension, extName, sqlFilePath);\n\n    if (!sqlFileContent) {\n      throw new Error(`Invalid SQL file for extension ${extName}`);\n    }\n\n    module.FS.writeFile(pgControlPath, controlFileContent);\n    module.FS.writeFile(`/usr/local/pgsql/share/extension/${sqlFileName}`, sqlFileContent);\n  }\n\n  /**\n   * Perform the first run initialization of the database\n   * This is only run when the database is first created\n   */\n  async #firstRun() {\n    const shareDir = \"/usr/local/pgsql/share\";\n    const sqlFiles = [\n      [\"information_schema.sql\"],\n      [\"system_constraints.sql\", \"pg_catalog\"],\n      [\"system_functions.sql\", \"pg_catalog\"],\n      [\"system_views.sql\", \"pg_catalog\"],\n    ];\n    // Load the sql files into the database\n    for (const [file, schema] of sqlFiles) {\n      const sql = await this.emp.FS.readFile(shareDir + \"/\" + file, {\n        encoding: \"utf8\",\n      });\n      if (schema) {\n        await this.#runExec(`SET search_path TO ${schema};\\n ${sql}`);\n      } else {\n        await this.#runExec(sql);\n      }\n    }\n    await this.#runExec(`\n      SET search_path TO public;\n      CREATE EXTENSION IF NOT EXISTS plpgsql;\n    `);\n  }\n\n  /**\n   * The ready state of the database\n   */\n  get ready() {\n    return this.#ready && !this.#closing && !this.#closed;\n  }\n\n  /**\n   * The closed state of the database\n   */\n  get closed() {\n    return this.#closed;\n  }\n\n  /**\n   * Close the database\n   * @returns A promise that resolves when the database is closed\n   */\n  async close() {\n    await this.#checkReady();\n    this.#closing = true;\n\n    // Close all extensions\n    for (const closeFn of this.#extensionsClose) {\n      await closeFn();\n    }\n\n    // Close the database\n    await new Promise<void>(async (resolve, reject) => {\n      try {\n        await this.execProtocol(serialize.end());\n      } catch (e) {\n        const err = e as { name: string; status: number };\n        if (err.name === \"ExitStatus\" && err.status === 0) {\n          resolve();\n        } else {\n          reject(e);\n        }\n      }\n    });\n    this.#closed = true;\n    this.#closing = false;\n  }\n\n  /**\n   * Execute a single SQL statement\n   * This uses the \"Extended Query\" postgres wire protocol message.\n   * @param query The query to execute\n   * @param params Optional parameters for the query\n   * @returns The result of the query\n   */\n  async query<T>(\n    query: string,\n    params?: any[],\n    options?: QueryOptions,\n  ): Promise<Results<T>> {\n    await this.#checkReady();\n    // We wrap the public query method in the transaction mutex to ensure that\n    // only one query can be executed at a time and not concurrently with a\n    // transaction.\n    return await this.#transactionMutex.runExclusive(async () => {\n      return await this.#runQuery<T>(query, params, options);\n    });\n  }\n\n  /**\n   * Execute a SQL query, this can have multiple statements.\n   * This uses the \"Simple Query\" postgres wire protocol message.\n   * @param query The query to execute\n   * @returns The result of the query\n   */\n  async exec(query: string, options?: QueryOptions): Promise<Array<Results>> {\n    await this.#checkReady();\n    // We wrap the public exec method in the transaction mutex to ensure that\n    // only one query can be executed at a time and not concurrently with a\n    // transaction.\n    return await this.#transactionMutex.runExclusive(async () => {\n      return await this.#runExec(query, options);\n    });\n  }\n\n  /**\n   * Internal method to execute a query\n   * Not protected by the transaction mutex, so it can be used inside a transaction\n   * @param query The query to execute\n   * @param params Optional parameters for the query\n   * @returns The result of the query\n   */\n  async #runQuery<T>(\n    query: string,\n    params?: any[],\n    options?: QueryOptions,\n  ): Promise<Results<T>> {\n    return await this.#queryMutex.runExclusive(async () => {\n      // We need to parse, bind and execute a query with parameters\n      this.#log(\"runQuery\", query, params, options);\n      await this.#handleBlob(options?.blob);\n      const parsedParams = params?.map((p) => serializeType(p)) || [];\n      let results;\n      try {\n        results = [\n          ...(await this.#execProtocolNoSync(\n            serialize.parse({\n              text: query,\n              types: parsedParams.map(([, type]) => type),\n            }),\n          )),\n          ...(await this.#execProtocolNoSync(\n            serialize.bind({\n              values: parsedParams.map(([val]) => val),\n            }),\n          )),\n          ...(await this.#execProtocolNoSync(\n            serialize.describe({ type: \"P\" }),\n          )),\n          ...(await this.#execProtocolNoSync(serialize.execute({}))),\n        ];\n      } finally {\n        await this.#execProtocolNoSync(serialize.sync());\n      }\n      this.#cleanupBlob();\n      if (!this.#inTransaction) {\n        await this.#syncToFs();\n      }\n      let blob: Blob | undefined;\n      if (this.#queryWriteChunks) {\n        blob = new Blob(this.#queryWriteChunks);\n        this.#queryWriteChunks = undefined;\n      }\n      return parseResults(\n        results.map(([msg]) => msg),\n        options,\n        blob,\n      )[0] as Results<T>;\n    });\n  }\n\n  /**\n   * Internal method to execute a query\n   * Not protected by the transaction mutex, so it can be used inside a transaction\n   * @param query The query to execute\n   * @param params Optional parameters for the query\n   * @returns The result of the query\n   */\n  async #runExec(\n    query: string,\n    options?: QueryOptions,\n  ): Promise<Array<Results>> {\n    return await this.#queryMutex.runExclusive(async () => {\n      // No params so we can just send the query\n      this.#log(\"runExec\", query, options);\n      await this.#handleBlob(options?.blob);\n      let results;\n      try {\n        results = await this.#execProtocolNoSync(serialize.query(query));\n      } finally {\n        await this.#execProtocolNoSync(serialize.sync());\n      }\n      this.#cleanupBlob();\n      if (!this.#inTransaction) {\n        await this.#syncToFs();\n      }\n      let blob: Blob | undefined;\n      if (this.#queryWriteChunks) {\n        blob = new Blob(this.#queryWriteChunks);\n        this.#queryWriteChunks = undefined;\n      }\n      return parseResults(\n        results.map(([msg]) => msg),\n        options,\n        blob,\n      ) as Array<Results>;\n    });\n  }\n\n  /**\n   * Execute a transaction\n   * @param callback A callback function that takes a transaction object\n   * @returns The result of the transaction\n   */\n  async transaction<T>(\n    callback: (tx: Transaction) => Promise<T>,\n  ): Promise<T | undefined> {\n    await this.#checkReady();\n    return await this.#transactionMutex.runExclusive(async () => {\n      await this.#runExec(\"BEGIN\");\n\n      // Once a transaction is closed, we throw an error if it's used again\n      let closed = false;\n      const checkClosed = () => {\n        if (closed) {\n          throw new Error(\"Transaction is closed\");\n        }\n      };\n\n      try {\n        const tx: Transaction = {\n          query: async (\n            query: string,\n            params?: any[],\n            options?: QueryOptions,\n          ) => {\n            checkClosed();\n            return await this.#runQuery(query, params, options);\n          },\n          exec: async (query: string, options?: QueryOptions) => {\n            checkClosed();\n            return await this.#runExec(query, options);\n          },\n          rollback: async () => {\n            checkClosed();\n            // Rollback and set the closed flag to prevent further use of this\n            // transaction\n            await this.#runExec(\"ROLLBACK\");\n            closed = true;\n          },\n          get closed() {\n            return closed;\n          },\n        };\n        const result = await callback(tx);\n        if (!closed) {\n          closed = true;\n          await this.#runExec(\"COMMIT\");\n        }\n        return result;\n      } catch (e) {\n        if (!closed) {\n          await this.#runExec(\"ROLLBACK\");\n        }\n        throw e;\n      }\n    });\n  }\n\n  /**\n   * Handle a file attached to the current query\n   * @param file The file to handle\n   */\n  async #handleBlob(blob?: File | Blob) {\n    this.#queryReadBuffer = blob ? await blob.arrayBuffer() : undefined;\n  }\n\n  /**\n   * Cleanup the current file\n   */\n  #cleanupBlob() {\n    this.#queryReadBuffer = undefined;\n  }\n\n  /**\n   * Wait for the database to be ready\n   */\n  async #checkReady() {\n    if (this.#closing) {\n      throw new Error(\"PGlite is closing\");\n    }\n    if (this.#closed) {\n      throw new Error(\"PGlite is closed\");\n    }\n    if (!this.#ready) {\n      // Starting the database can take a while and it might not be ready yet\n      // We'll wait for it to be ready before continuing\n      await this.waitReady;\n    }\n  }\n\n  /**\n   * Execute a postgres wire protocol message\n   * @param message The postgres wire protocol message to execute\n   * @returns The result of the query\n   */\n  async execProtocol(\n    message: Uint8Array,\n    { syncToFs = true }: ExecProtocolOptions = {},\n  ): Promise<Array<[BackendMessage, Uint8Array]>> {\n    return await this.#executeMutex.runExclusive(async () => {\n      if (this.#resultAccumulator.length > 0) {\n        this.#resultAccumulator = [];\n      }\n\n      var bytes = message.length;\n      var ptr = this.emp.___libc_malloc(bytes);\n      this.emp.HEAPU8.set(message, ptr);\n      await this.emp.ccall(\"ExecProtocolMsg\", \"void\", [\"pointer\"], [ptr], { async: true })\n\n      if (syncToFs) {\n        await this.#syncToFs();\n      }\n\n      const resData = this.#resultAccumulator;\n\n      const results: Array<[BackendMessage, Uint8Array]> = [];\n\n      resData.forEach((data) => {\n        this.#parser.parse(Buffer.from(data), (msg) => {\n          if (msg instanceof DatabaseError) {\n            this.#parser = new Parser(); // Reset the parser\n            throw msg;\n            // TODO: Do we want to wrap the error in a custom error?\n          } else if (msg instanceof NoticeMessage && this.debug > 0) {\n            // Notice messages are warnings, we should log them\n            console.warn(msg);\n          } else if (msg instanceof CommandCompleteMessage) {\n            // Keep track of the transaction state\n            switch (msg.text) {\n              case \"BEGIN\":\n                this.#inTransaction = true;\n                break;\n              case \"COMMIT\":\n              case \"ROLLBACK\":\n                this.#inTransaction = false;\n                break;\n            }\n          } else if (msg instanceof NotificationResponseMessage) {\n            // We've received a notification, call the listeners\n            const listeners = this.#notifyListeners.get(msg.channel);\n            if (listeners) {\n              listeners.forEach((cb) => {\n                // We use queueMicrotask so that the callback is called after any\n                // synchronous code has finished running.\n                queueMicrotask(() => cb(msg.payload));\n              });\n            }\n            this.#globalNotifyListeners.forEach((cb) => {\n              queueMicrotask(() => cb(msg.channel, msg.payload));\n            });\n          }\n          results.push([msg, data]);\n        });\n      });\n\n      return results;\n    });\n  }\n\n  async #execProtocolNoSync(\n    message: Uint8Array,\n  ): Promise<Array<[BackendMessage, Uint8Array]>> {\n    return await this.execProtocol(message, { syncToFs: false });\n  }\n\n  /**\n   * Perform any sync operations implemented by the filesystem, this is\n   * run after every query to ensure that the filesystem is synced.\n   */\n  async #syncToFs() {\n    if (this.#fsSyncScheduled) {\n      return;\n    }\n    this.#fsSyncScheduled = true;\n\n    const doSync = async () => {\n      await this.#fsSyncMutex.runExclusive(async () => {\n        this.#fsSyncScheduled = false;\n        await this.fs!.syncToFs(this.emp.FS);\n      });\n    };\n\n    if (this.#relaxedDurability) {\n      doSync();\n    } else {\n      await doSync();\n    }\n  }\n\n  /**\n   * Internal log function\n   */\n  #log(...args: any[]) {\n    if (this.debug > 0) {\n      console.log(...args);\n    }\n  }\n\n  /**\n   * Listen for a notification\n   * @param channel The channel to listen on\n   * @param callback The callback to call when a notification is received\n   */\n  async listen(channel: string, callback: (payload: string) => void) {\n    if (!this.#notifyListeners.has(channel)) {\n      this.#notifyListeners.set(channel, new Set());\n    }\n    this.#notifyListeners.get(channel)!.add(callback);\n    await this.exec(`LISTEN ${channel}`);\n    return async () => {\n      await this.unlisten(channel, callback);\n    };\n  }\n\n  /**\n   * Stop listening for a notification\n   * @param channel The channel to stop listening on\n   * @param callback The callback to remove\n   */\n  async unlisten(channel: string, callback?: (payload: string) => void) {\n    if (callback) {\n      this.#notifyListeners.get(channel)?.delete(callback);\n      if (this.#notifyListeners.get(channel)!.size === 0) {\n        await this.exec(`UNLISTEN ${channel}`);\n        this.#notifyListeners.delete(channel);\n      }\n    } else {\n      await this.exec(`UNLISTEN ${channel}`);\n      this.#notifyListeners.delete(channel);\n    }\n  }\n\n  /**\n   * Listen to notifications\n   * @param callback The callback to call when a notification is received\n   */\n  onNotification(\n    callback: (channel: string, payload: string) => void,\n  ): () => void {\n    this.#globalNotifyListeners.add(callback);\n    return () => {\n      this.#globalNotifyListeners.delete(callback);\n    };\n  }\n\n  /**\n   * Stop listening to notifications\n   * @param callback The callback to remove\n   */\n  offNotification(callback: (channel: string, payload: string) => void) {\n    this.#globalNotifyListeners.delete(callback);\n  }\n\n  /**\n   * Create a new PGlite instance with extensions on the Typescript interface\n   * (The main constructor does enable extensions, however due to the limitations\n   * of Typescript, the extensions are not available on the instance interface)\n   * @param dataDir The directory to store the database files\n   *                Prefix with idb:// to use indexeddb filesystem in the browser\n   *                Use memory:// to use in-memory filesystem\n   * @param options Optional options\n   * @returns A new PGlite instance with extensions\n   */\n  static withExtensions<O extends PGliteOptions>(\n    options?: O,\n  ): PGlite & PGliteInterfaceExtensions<O[\"extensions\"]> {\n    return new PGlite(options) as any;\n  }\n}\n","const E_TIMEOUT = new Error('timeout while waiting for mutex to become available');\nconst E_ALREADY_LOCKED = new Error('mutex already locked');\nconst E_CANCELED = new Error('request for lock canceled');\n\nvar __awaiter$2 = (undefined && undefined.__awaiter) || function (thisArg, _arguments, P, generator) {\n    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }\n    return new (P || (P = Promise))(function (resolve, reject) {\n        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }\n        function rejected(value) { try { step(generator[\"throw\"](value)); } catch (e) { reject(e); } }\n        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }\n        step((generator = generator.apply(thisArg, _arguments || [])).next());\n    });\n};\nclass Semaphore {\n    constructor(_value, _cancelError = E_CANCELED) {\n        this._value = _value;\n        this._cancelError = _cancelError;\n        this._weightedQueues = [];\n        this._weightedWaiters = [];\n    }\n    acquire(weight = 1) {\n        if (weight <= 0)\n            throw new Error(`invalid weight ${weight}: must be positive`);\n        return new Promise((resolve, reject) => {\n            if (!this._weightedQueues[weight - 1])\n                this._weightedQueues[weight - 1] = [];\n            this._weightedQueues[weight - 1].push({ resolve, reject });\n            this._dispatch();\n        });\n    }\n    runExclusive(callback, weight = 1) {\n        return __awaiter$2(this, void 0, void 0, function* () {\n            const [value, release] = yield this.acquire(weight);\n            try {\n                return yield callback(value);\n            }\n            finally {\n                release();\n            }\n        });\n    }\n    waitForUnlock(weight = 1) {\n        if (weight <= 0)\n            throw new Error(`invalid weight ${weight}: must be positive`);\n        return new Promise((resolve) => {\n            if (!this._weightedWaiters[weight - 1])\n                this._weightedWaiters[weight - 1] = [];\n            this._weightedWaiters[weight - 1].push(resolve);\n            this._dispatch();\n        });\n    }\n    isLocked() {\n        return this._value <= 0;\n    }\n    getValue() {\n        return this._value;\n    }\n    setValue(value) {\n        this._value = value;\n        this._dispatch();\n    }\n    release(weight = 1) {\n        if (weight <= 0)\n            throw new Error(`invalid weight ${weight}: must be positive`);\n        this._value += weight;\n        this._dispatch();\n    }\n    cancel() {\n        this._weightedQueues.forEach((queue) => queue.forEach((entry) => entry.reject(this._cancelError)));\n        this._weightedQueues = [];\n    }\n    _dispatch() {\n        var _a;\n        for (let weight = this._value; weight > 0; weight--) {\n            const queueEntry = (_a = this._weightedQueues[weight - 1]) === null || _a === void 0 ? void 0 : _a.shift();\n            if (!queueEntry)\n                continue;\n            const previousValue = this._value;\n            const previousWeight = weight;\n            this._value -= weight;\n            weight = this._value + 1;\n            queueEntry.resolve([previousValue, this._newReleaser(previousWeight)]);\n        }\n        this._drainUnlockWaiters();\n    }\n    _newReleaser(weight) {\n        let called = false;\n        return () => {\n            if (called)\n                return;\n            called = true;\n            this.release(weight);\n        };\n    }\n    _drainUnlockWaiters() {\n        for (let weight = this._value; weight > 0; weight--) {\n            if (!this._weightedWaiters[weight - 1])\n                continue;\n            this._weightedWaiters[weight - 1].forEach((waiter) => waiter());\n            this._weightedWaiters[weight - 1] = [];\n        }\n    }\n}\n\nvar __awaiter$1 = (undefined && undefined.__awaiter) || function (thisArg, _arguments, P, generator) {\n    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }\n    return new (P || (P = Promise))(function (resolve, reject) {\n        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }\n        function rejected(value) { try { step(generator[\"throw\"](value)); } catch (e) { reject(e); } }\n        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }\n        step((generator = generator.apply(thisArg, _arguments || [])).next());\n    });\n};\nclass Mutex {\n    constructor(cancelError) {\n        this._semaphore = new Semaphore(1, cancelError);\n    }\n    acquire() {\n        return __awaiter$1(this, void 0, void 0, function* () {\n            const [, releaser] = yield this._semaphore.acquire();\n            return releaser;\n        });\n    }\n    runExclusive(callback) {\n        return this._semaphore.runExclusive(() => callback());\n    }\n    isLocked() {\n        return this._semaphore.isLocked();\n    }\n    waitForUnlock() {\n        return this._semaphore.waitForUnlock();\n    }\n    release() {\n        if (this._semaphore.isLocked())\n            this._semaphore.release();\n    }\n    cancel() {\n        return this._semaphore.cancel();\n    }\n}\n\nvar __awaiter = (undefined && undefined.__awaiter) || function (thisArg, _arguments, P, generator) {\n    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }\n    return new (P || (P = Promise))(function (resolve, reject) {\n        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }\n        function rejected(value) { try { step(generator[\"throw\"](value)); } catch (e) { reject(e); } }\n        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }\n        step((generator = generator.apply(thisArg, _arguments || [])).next());\n    });\n};\nfunction withTimeout(sync, timeout, timeoutError = E_TIMEOUT) {\n    return {\n        acquire: (weight) => {\n            if (weight !== undefined && weight <= 0) {\n                throw new Error(`invalid weight ${weight}: must be positive`);\n            }\n            return new Promise((resolve, reject) => __awaiter(this, void 0, void 0, function* () {\n                let isTimeout = false;\n                const handle = setTimeout(() => {\n                    isTimeout = true;\n                    reject(timeoutError);\n                }, timeout);\n                try {\n                    const ticket = yield sync.acquire(weight);\n                    if (isTimeout) {\n                        const release = Array.isArray(ticket) ? ticket[1] : ticket;\n                        release();\n                    }\n                    else {\n                        clearTimeout(handle);\n                        resolve(ticket);\n                    }\n                }\n                catch (e) {\n                    if (!isTimeout) {\n                        clearTimeout(handle);\n                        reject(e);\n                    }\n                }\n            }));\n        },\n        runExclusive(callback, weight) {\n            return __awaiter(this, void 0, void 0, function* () {\n                let release = () => undefined;\n                try {\n                    const ticket = yield this.acquire(weight);\n                    if (Array.isArray(ticket)) {\n                        release = ticket[1];\n                        return yield callback(ticket[0]);\n                    }\n                    else {\n                        release = ticket;\n                        return yield callback();\n                    }\n                }\n                finally {\n                    release();\n                }\n            });\n        },\n        release(weight) {\n            sync.release(weight);\n        },\n        cancel() {\n            return sync.cancel();\n        },\n        waitForUnlock: (weight) => {\n            if (weight !== undefined && weight <= 0) {\n                throw new Error(`invalid weight ${weight}: must be positive`);\n            }\n            return new Promise((resolve, reject) => {\n                const handle = setTimeout(() => reject(timeoutError), timeout);\n                sync.waitForUnlock(weight).then(() => {\n                    clearTimeout(handle);\n                    resolve();\n                });\n            });\n        },\n        isLocked: () => sync.isLocked(),\n        getValue: () => sync.getValue(),\n        setValue: (value) => sync.setValue(value),\n    };\n}\n\n// eslint-disable-next-lisne @typescript-eslint/explicit-module-boundary-types\nfunction tryAcquire(sync, alreadyAcquiredError = E_ALREADY_LOCKED) {\n    // eslint-disable-next-line @typescript-eslint/no-explicit-any\n    return withTimeout(sync, 0, alreadyAcquiredError);\n}\n\nexport { E_ALREADY_LOCKED, E_CANCELED, E_TIMEOUT, Mutex, Semaphore, tryAcquire, withTimeout };\n","import { IN_NODE } from \"./utils.js\";\n\nlet PGEvent: typeof CustomEvent;\n\n// Older versions of Node.js do not have CustomEvent\nif (IN_NODE && typeof CustomEvent === \"undefined\") {\n  PGEvent = class CustomEvent<T> extends Event {\n    #detail: T | null;\n\n    constructor(type: string, options?: EventInit & { detail: T }) {\n      super(type, options);\n      this.#detail = options?.detail ?? null;\n    }\n\n    get detail() {\n      return this.#detail;\n    }\n  } as typeof CustomEvent;\n} else {\n  PGEvent = CustomEvent;\n}\n\nexport { PGEvent };\n","import {\n  BackendMessage,\n  RowDescriptionMessage,\n  DataRowMessage,\n  CommandCompleteMessage,\n} from \"pg-protocol/dist/messages.js\";\nimport type { Results, QueryOptions } from \"./interface.js\";\nimport { parseType } from \"./types.js\";\n\n/**\n * This function is used to parse the results of either a simple or extended query.\n * https://www.postgresql.org/docs/current/protocol-flow.html#PROTOCOL-FLOW-SIMPLE-QUERY\n */\nexport function parseResults(\n  messages: Array<BackendMessage>,\n  options?: QueryOptions,\n  blob?: Blob\n): Array<Results> {\n  const resultSets: Results[] = [];\n  let currentResultSet: Results = { rows: [], fields: [] };\n  let affectedRows = 0;\n\n  const filteredMessages = messages.filter(\n    (msg) =>\n      msg instanceof RowDescriptionMessage ||\n      msg instanceof DataRowMessage ||\n      msg instanceof CommandCompleteMessage\n  );\n\n  filteredMessages.forEach((msg, index) => {\n    if (msg instanceof RowDescriptionMessage) {\n      currentResultSet.fields = msg.fields.map((field) => ({\n        name: field.name,\n        dataTypeID: field.dataTypeID,\n      }));\n    } else if (msg instanceof DataRowMessage && currentResultSet) {\n      if (options?.rowMode === \"array\") {\n        currentResultSet.rows.push(\n          msg.fields.map((field, i) =>\n            parseType(\n              field,\n              currentResultSet!.fields[i].dataTypeID,\n              options?.parsers\n            )\n          )\n        );\n      } else {\n        // rowMode === \"object\"\n        currentResultSet.rows.push(\n          Object.fromEntries(\n            msg.fields.map((field, i) => [\n              currentResultSet!.fields[i].name,\n              parseType(\n                field,\n                currentResultSet!.fields[i].dataTypeID,\n                options?.parsers\n              ),\n            ])\n          )\n        );\n      }\n    } else if (msg instanceof CommandCompleteMessage) {\n      affectedRows += retrieveRowCount(msg);\n\n      if (index === filteredMessages.length - 1)\n        resultSets.push({\n          ...currentResultSet,\n          affectedRows,\n          ...(blob ? { blob } : {}),\n        });\n      else resultSets.push(currentResultSet);\n\n      currentResultSet = { rows: [], fields: [] };\n    }\n  });\n\n  if (resultSets.length === 0) {\n    resultSets.push({\n      rows: [],\n      fields: [],\n    });\n  }\n\n  return resultSets;\n}\n\nfunction retrieveRowCount(msg: CommandCompleteMessage): number {\n  const parts = msg.text.split(\" \");\n  switch (parts[0]) {\n    case \"INSERT\":\n      return parseInt(parts[2], 10);\n    case \"UPDATE\":\n    case \"DELETE\":\n      return parseInt(parts[1], 10);\n    default:\n      return 0;\n  }\n}\n","import type { ParserOptions } from \"./interface.js\";\n\nconst JSON_parse = globalThis.JSON.parse;\nconst JSON_stringify = globalThis.JSON.stringify;\n\nexport const BOOL = 16,\n  BYTEA = 17,\n  CHAR = 18,\n  INT8 = 20,\n  INT2 = 21,\n  INT4 = 23,\n  REGPROC = 24,\n  TEXT = 25,\n  OID = 26,\n  TID = 27,\n  XID = 28,\n  CID = 29,\n  JSON = 114,\n  XML = 142,\n  PG_NODE_TREE = 194,\n  SMGR = 210,\n  PATH = 602,\n  POLYGON = 604,\n  CIDR = 650,\n  FLOAT4 = 700,\n  FLOAT8 = 701,\n  ABSTIME = 702,\n  RELTIME = 703,\n  TINTERVAL = 704,\n  CIRCLE = 718,\n  MACADDR8 = 774,\n  MONEY = 790,\n  MACADDR = 829,\n  INET = 869,\n  ACLITEM = 1033,\n  BPCHAR = 1042,\n  VARCHAR = 1043,\n  DATE = 1082,\n  TIME = 1083,\n  TIMESTAMP = 1114,\n  TIMESTAMPTZ = 1184,\n  INTERVAL = 1186,\n  TIMETZ = 1266,\n  BIT = 1560,\n  VARBIT = 1562,\n  NUMERIC = 1700,\n  REFCURSOR = 1790,\n  REGPROCEDURE = 2202,\n  REGOPER = 2203,\n  REGOPERATOR = 2204,\n  REGCLASS = 2205,\n  REGTYPE = 2206,\n  UUID = 2950,\n  TXID_SNAPSHOT = 2970,\n  PG_LSN = 3220,\n  PG_NDISTINCT = 3361,\n  PG_DEPENDENCIES = 3402,\n  TSVECTOR = 3614,\n  TSQUERY = 3615,\n  GTSVECTOR = 3642,\n  REGCONFIG = 3734,\n  REGDICTIONARY = 3769,\n  JSONB = 3802,\n  REGNAMESPACE = 4089,\n  REGROLE = 4096;\n\nexport const arrayTypes = {\n  1001: BYTEA,\n  1002: CHAR,\n  1016: INT8,\n  1005: INT2,\n  1007: INT4,\n  1009: TEXT,\n  1028: OID,\n  199: JSON,\n  1021: FLOAT4,\n  1022: FLOAT8,\n  1015: VARCHAR,\n  3807: JSONB,\n  1182: DATE,\n  1115: TIMESTAMP,\n  1116: TIMESTAMPTZ,\n};\n\nexport const types = {\n  string: {\n    to: 0,\n    from: [TEXT, VARCHAR],\n    serialize: (x: string) => x,\n    parse: (x: string) => x,\n  },\n  number: {\n    to: 0,\n    from: [INT2, INT4, OID, FLOAT4, FLOAT8],\n    serialize: (x: number) => x.toString(),\n    parse: (x: string) => +x,\n  },\n  bigint: {\n    to: INT8,\n    from: [INT8],\n    js: [BigInt],\n    serialize: (x: BigInt) => x.toString(),\n    parse: (x: string) => {\n      const n = BigInt(x);\n      if (n < Number.MIN_SAFE_INTEGER || n > Number.MAX_SAFE_INTEGER) {\n        return n; // return BigInt\n      } else {\n        return Number(n); // in range of standard JS numbers so return number\n      }\n    },\n  },\n  json: {\n    to: JSON,\n    from: [JSON, JSONB],\n    serialize: (x: any) => JSON_stringify(x),\n    parse: (x: string) => JSON_parse(x),\n  },\n  boolean: {\n    to: BOOL,\n    from: [BOOL],\n    serialize: (x: boolean) => (x === true ? \"t\" : \"f\"),\n    parse: (x: string) => x === \"t\",\n  },\n  date: {\n    to: 1184,\n    from: [DATE, TIMESTAMP, TIMESTAMPTZ],\n    js: [Date],\n    serialize: (x: Date | string | number) =>\n      (x instanceof Date ? x : new Date(x)).toISOString(),\n    parse: (x: string | number) => new Date(x),\n  },\n  bytea: {\n    to: BYTEA,\n    from: [BYTEA],\n    js: [Uint8Array, Buffer],\n    serialize: (x: Uint8Array) => \"\\\\x\" + Buffer.from(x).toString(\"hex\"),\n    parse: (x: string): Uint8Array =>\n      new Uint8Array(Buffer.from(x.slice(2), \"hex\")),\n  },\n  array: {\n    to: 0,\n    from: Object.keys(arrayTypes).map((x) => +x),\n    serialize: (x: any[]) => serializeArray(x),\n    parse: (x: string, typeId?: number) => {\n      let parser;\n      if (typeId && typeId in arrayTypes) {\n        parser = parsers[arrayTypes[typeId as keyof typeof arrayTypes]];\n      }\n      return parseArray(x, parser);\n    },\n  },\n} satisfies TypeHandlers;\n\nexport type TypeHandler = {\n  to: number;\n  from: number | number[];\n  js?: any;\n  serialize: (x: any) => string;\n  parse: (x: string, typeId?: number) => any;\n};\n\nexport type TypeHandlers = {\n  [key: string]: TypeHandler;\n};\n\nconst defaultHandlers = typeHandlers(types);\n\nexport const parsers = defaultHandlers.parsers;\nexport const serializers = defaultHandlers.serializers;\nexport const serializerInstanceof = defaultHandlers.serializerInstanceof;\n\nexport type Serializer = (x: any) => [string, number];\n\nexport function serializerFor(x: any): Serializer {\n  if (Array.isArray(x)) {\n    return serializers.array;\n  }\n  const handler = serializers[typeof x];\n  if (handler) {\n    return handler;\n  }\n  for (const [Type, handler] of serializerInstanceof) {\n    if (x instanceof Type) {\n      return handler;\n    }\n  }\n  return serializers.json;\n}\n\nexport function serializeType(x: any): [string | null, number] {\n  if (x === null || x === undefined) {\n    return [null, 0];\n  }\n  return serializerFor(x)(x);\n}\n\nfunction escapeElement(elementRepresentation: string) {\n  const escaped = elementRepresentation\n    .replace(/\\\\/g, \"\\\\\\\\\")\n    .replace(/\"/g, '\\\\\"');\n  return '\"' + escaped + '\"';\n}\n\nfunction serializeArray(x: any[]) {\n  let result = \"{\";\n  for (let i = 0; i < x.length; i++) {\n    if (i > 0) {\n      result = result + \",\";\n    }\n    if (x[i] === null || typeof x[i] === \"undefined\") {\n      result = result + \"NULL\";\n    } else if (Array.isArray(x[i])) {\n      result = result + serializeArray(x[i]);\n    } else if (ArrayBuffer.isView(x[i])) {\n      let item = x[i];\n      if (!(item instanceof Buffer)) {\n        const buf = Buffer.from(item.buffer, item.byteOffset, item.byteLength);\n        if (buf.length === item.byteLength) {\n          item = buf;\n        } else {\n          item = buf.slice(item.byteOffset, item.byteOffset + item.byteLength);\n        }\n      }\n      result += \"\\\\\\\\x\" + item.toString(\"hex\");\n    } else {\n      result += escapeElement(serializeType(x[i])[0]!);\n    }\n  }\n  result = result + \"}\";\n  return result;\n}\n\nexport function parseArray(value: string, parser?: (s: string) => any) {\n  let i = 0;\n  let char = null;\n  let str = \"\";\n  let quoted = false;\n  let last = 0;\n  let p: string | undefined = undefined;\n\n  function loop(x: string): any[] {\n    const xs = [];\n    for (; i < x.length; i++) {\n      char = x[i];\n      if (quoted) {\n        if (char === \"\\\\\") {\n          str += x[++i];\n        } else if (char === '\"') {\n          xs.push(parser ? parser(str) : str);\n          str = \"\";\n          quoted = x[i + 1] === '\"';\n          last = i + 2;\n        } else {\n          str += char;\n        }\n      } else if (char === '\"') {\n        quoted = true;\n      } else if (char === \"{\") {\n        last = ++i;\n        xs.push(loop(x));\n      } else if (char === \"}\") {\n        quoted = false;\n        last < i &&\n          xs.push(parser ? parser(x.slice(last, i)) : x.slice(last, i));\n        last = i + 1;\n        break;\n      } else if (char === \",\" && p !== \"}\" && p !== '\"') {\n        xs.push(parser ? parser(x.slice(last, i)) : x.slice(last, i));\n        last = i + 1;\n      }\n      p = char;\n    }\n    last < i &&\n      xs.push(parser ? parser(x.slice(last, i + 1)) : x.slice(last, i + 1));\n    return xs;\n  }\n\n  return loop(value)[0];\n}\n\nexport function parseType(\n  x: string,\n  type: number,\n  parsers?: ParserOptions,\n): any {\n  if (x === null) {\n    return null;\n  }\n  const handler = parsers?.[type] ?? defaultHandlers.parsers[type];\n  if (handler) {\n    return handler(x, type);\n  } else {\n    return x;\n  }\n}\n\nfunction typeHandlers(types: TypeHandlers) {\n  return Object.keys(types).reduce(\n    ({ parsers, serializers, serializerInstanceof }, k) => {\n      const { to, from, serialize, parse = null } = types[k];\n      const theSerializer = (x: any) => [serialize(x), to] as [string, number];\n      serializers[to] = theSerializer;\n      serializers[k] = theSerializer;\n      if (types[k].js) {\n        types[k].js.forEach((Type: any) =>\n          serializerInstanceof.push([Type, theSerializer]),\n        );\n      }\n      if (parse) {\n        if (Array.isArray(from)) {\n          from.forEach((f) => (parsers[f] = parse));\n        } else {\n          parsers[from] = parse;\n        }\n        parsers[k] = parse;\n      }\n      return { parsers, serializers, serializerInstanceof };\n    },\n    {\n      parsers: {} as {\n        [key: number | string]: (x: string, typeId?: number) => any;\n      },\n      serializers: {} as {\n        [key: number | string]: Serializer;\n      },\n      serializerInstanceof: [] as Array<[any, Serializer]>,\n    },\n  );\n}\n","import type { BackendMessage } from \"pg-protocol/dist/messages.js\";\nimport type { Filesystem } from \"./fs/types.js\";\n\nexport type FilesystemType = \"nodefs\" | \"idbfs\" | \"memoryfs\";\n\nexport type DebugLevel = 0 | 1 | 2 | 3 | 4 | 5;\n\nexport type RowMode = \"array\" | \"object\";\n\nexport interface ParserOptions {\n  [pgType: number]: (value: string) => any;\n}\n\nexport interface QueryOptions {\n  rowMode?: RowMode;\n  parsers?: ParserOptions;\n  blob?: Blob | File;\n}\n\nexport interface ExecProtocolOptions {\n  syncToFs?: boolean;\n}\n\nexport interface ExtensionSetupResult {\n  emscriptenOpts?: any;\n  namespaceObj?: any;\n  init?: () => Promise<void>;\n  close?: () => Promise<void>;\n}\n\nexport type ExtensionSetup = (\n  pg: PGliteInterface,\n  emscriptenOpts: any,\n) => Promise<ExtensionSetupResult>;\n\nexport interface Extension {\n  name?: string;\n  setup: ExtensionSetup;\n  pathOrUrl?: string;\n}\n\nexport type Extensions = {\n  [namespace: string]: Extension;\n};\n\nexport interface PGliteOptions {\n  dataDir?: string;\n  fs?: Filesystem;\n  debug?: DebugLevel;\n  relaxedDurability?: boolean;\n  extensions?: Extensions;\n}\n\nexport type PGliteInterface = {\n  readonly waitReady: Promise<void>;\n  readonly debug: DebugLevel;\n  readonly ready: boolean;\n  readonly closed: boolean;\n\n  close(): Promise<void>;\n  query<T>(\n    query: string,\n    params?: any[],\n    options?: QueryOptions,\n  ): Promise<Results<T>>;\n  exec(query: string, options?: QueryOptions): Promise<Array<Results>>;\n  transaction<T>(\n    callback: (tx: Transaction) => Promise<T>,\n  ): Promise<T | undefined>;\n  execProtocol(\n    message: Uint8Array,\n    options?: ExecProtocolOptions,\n  ): Promise<Array<[BackendMessage, Uint8Array]>>;\n  listen(\n    channel: string,\n    callback: (payload: string) => void,\n  ): Promise<() => Promise<void>>;\n  unlisten(\n    channel: string,\n    callback?: (payload: string) => void,\n  ): Promise<void>;\n  onNotification(\n    callback: (channel: string, payload: string) => void,\n  ): () => void;\n  offNotification(callback: (channel: string, payload: string) => void): void;\n};\n\nexport type PGliteInterfaceExtensions<E> = E extends Extensions\n  ? {\n    [K in keyof E]: Awaited<\n      ReturnType<E[K][\"setup\"]>\n    >[\"namespaceObj\"] extends infer N\n    ? N extends undefined | null | void\n    ? never\n    : N\n    : never;\n  }\n  : {};\n\nexport type Row<T = { [key: string]: any }> = T;\n\nexport type Results<T = { [key: string]: any }> = {\n  rows: Row<T>[];\n  affectedRows?: number;\n  fields: { name: string; dataTypeID: number }[];\n  blob?: Blob; // Only set when a file is returned, such as from a COPY command\n};\n\nexport interface Transaction {\n  query<T>(\n    query: string,\n    params?: any[],\n    options?: QueryOptions,\n  ): Promise<Results<T>>;\n  exec(query: string, options?: QueryOptions): Promise<Array<Results>>;\n  rollback(): Promise<void>;\n  get closed(): boolean;\n}\n"],"mappings":"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","names":["exports","DatabaseError","message","length","name","CopyDataMessage","chunk","CopyResponse","binary","columnCount","Field","tableID","columnID","dataTypeID","dataTypeSize","dataTypeModifier","format","RowDescriptionMessage","fieldCount","ParameterDescriptionMessage","parameterCount","ParameterStatusMessage","parameterName","parameterValue","AuthenticationMD5Password","salt","BackendKeyDataMessage","processID","secretKey","NotificationResponseMessage","processId","channel","payload","ReadyForQueryMessage","status","CommandCompleteMessage","text","DataRowMessage","fields","NoticeMessage","Writer","size","Buffer","remaining","oldBuffer","newSize","num","string","len","otherBuffer","code","length","result","exports","buffer_writer_1","writer","startup","opts","key","bodyBuffer","length","requestSsl","response","Buffer","password","sendSASLInitialResponseMessage","mechanism","initialResponse","sendSCRAMClientFinalMessage","additionalData","query","text","emptyArray","parse","name","types","len","buffer","i","paramWriter","writeValues","values","valueMapper","mappedVal","bind","config","portal","statement","binary","emptyExecute","execute","rows","portalLength","buff","cancel","processID","secretKey","cstringMessage","code","string","emptyDescribePortal","emptyDescribeStatement","describe","msg","close","copyData","chunk","copyFail","message","codeOnlyBuffer","flushBuffer","syncBuffer","endBuffer","copyDoneBuffer","serialize","exports","emptyBuffer","Buffer","BufferReader","offset","buffer","result","length","start","end","exports","require_blank","__commonJSMin","init_buffer","messages_1","buffer_reader_1","assert_1","__importDefault","CODE_LENGTH","LEN_LENGTH","HEADER_LENGTH","emptyBuffer","Buffer","Parser","opts","buffer","callback","bufferFullLength","offset","code","length","fullMessageLength","message","newLength","newBuffer","newBufferLength","bytes","status","text","chunk","messageName","isBinary","columnCount","i","processId","channel","payload","fieldCount","name","tableID","columnID","dataTypeID","dataTypeSize","dataTypeModifier","mode","parameterCount","fields","len","value","processID","secretKey","salt","mechanism","fieldType","messageValue","exports","messages_1","exports","serializer_1","parser_1","parse","stream","callback","parser","buffer","resolve","init_buffer","init_buffer","init_buffer","E_TIMEOUT","E_ALREADY_LOCKED","E_CANCELED","__awaiter$2","thisArg","_arguments","P","generator","adopt","value","resolve","reject","fulfilled","step","e","rejected","result","Semaphore","_value","_cancelError","weight","callback","release","queue","entry","_a","queueEntry","previousValue","previousWeight","called","waiter","__awaiter$1","Mutex","cancelError","releaser","init_buffer","PGEvent","_detail","_a","IN_NODE","type","options","__privateAdd","__privateSet","__privateGet","parse_exports","__export","parseResults","init_buffer","import_messages","types_exports","__export","ABSTIME","ACLITEM","BIT","BOOL","BPCHAR","BYTEA","CHAR","CID","CIDR","CIRCLE","DATE","FLOAT4","FLOAT8","GTSVECTOR","INET","INT2","INT4","INT8","INTERVAL","JSON","JSONB","MACADDR","MACADDR8","MONEY","NUMERIC","OID","PATH","PG_DEPENDENCIES","PG_LSN","PG_NDISTINCT","PG_NODE_TREE","POLYGON","REFCURSOR","REGCLASS","REGCONFIG","REGDICTIONARY","REGNAMESPACE","REGOPER","REGOPERATOR","REGPROC","REGPROCEDURE","REGROLE","REGTYPE","RELTIME","SMGR","TEXT","TID","TIME","TIMESTAMP","TIMESTAMPTZ","TIMETZ","TINTERVAL","TSQUERY","TSVECTOR","TXID_SNAPSHOT","UUID","VARBIT","VARCHAR","XID","XML","arrayTypes","parseArray","parseType","parsers","serializeType","serializerFor","serializerInstanceof","serializers","types","init_buffer","JSON_parse","JSON_stringify","x","n","Buffer","serializeArray","typeId","parser","defaultHandlers","typeHandlers","handler","Type","escapeElement","elementRepresentation","result","i","item","buf","value","char","str","quoted","last","p","loop","xs","type","k","to","from","serialize","parse","theSerializer","f","parseResults","messages","options","blob","resultSets","currentResultSet","affectedRows","filteredMessages","msg","index","field","i","parseType","retrieveRowCount","parts","import_dist","import_parser","import_messages","_extensions","_initStarted","_ready","_eventTarget","_closing","_closed","_inTransaction","_relaxedDurability","_extensionsClose","_resultAccumulator","_executeMutex","_queryMutex","_transactionMutex","_fsSyncMutex","_fsSyncScheduled","_parser","_queryReadBuffer","_queryWriteChunks","_notifyListeners","_globalNotifyListeners","_init","init_fn","__addExtension","_addExtension_fn","_firstRun","firstRun_fn","_runQuery","runQuery_fn","_runExec","runExec_fn","_handleBlob","handleBlob_fn","_cleanupBlob","cleanupBlob_fn","_checkReady","checkReady_fn","_execProtocolNoSync","execProtocolNoSync_fn","_syncToFs","syncToFs_fn","_log","log_fn","_PGlite","dataDirOrPGliteOptions","options","__privateAdd","Mutex","__privateSet","__privateGet","e","__privateMethod","extName","extension","closeFn","resolve","reject","err","query","params","callback","closed","checkClosed","result","message","syncToFs","bytes","ptr","resData","results","data","Buffer","msg","listeners","cb","channel","dataDir","fsType","parseDataDir","loadFs","extensionInitFns","firstRun","emscriptenOpts","makeLocateFile","mod","devId","callCounter","devOpt","stream","buffer","offset","length","position","buf","contents","size","i","whence","Module","ext","PGEvent","extRet","emp","postgres_default","initFn","module","pgControlPath","fileExists","controlFileContent","getExtensionControlFile","extensionVersion","getExtensionVersionFromControlFile","sqlFileName","sqlFilePath","sqlFileContent","getExtensionSqlScript","shareDir","sqlFiles","file","schema","sql","parsedParams","p","serializeType","type","val","blob","parseResults","doSync","args","PGlite","init_buffer","messages","protocol"]}